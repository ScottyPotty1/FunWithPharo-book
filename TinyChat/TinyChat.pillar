! TinyChat: a Fun and Small Chat Client/ServerPharo allows the definition of a REST server in a couple of lines of code thanks to the package Teapot which extends the superb HTTP client/server Zinc developed by BetaNine and given to the community. The goals of this chapter is to make you develop in five small classes, a client/server chat application with a graphical client.This little adventure will let you get familiar with Pharo and show the ease with which Pharo lets you define a REST server.Developed in a couple of hours, TinyChat has been designed as a pedagogical application. At the end of the chapter, we propose a list of possible improvements. !! Objectives and ArchitectureWe are going to build a chat server and one graphical client as shown in Figure *tinychatclient*. +Chatting with TinyChat>file://figures/tinychatclient.png|width=80|label=tinychatclient+The communication between the client and the server will be based on HTTP and REST.In addition to the classes ==TCServer== et ==TinyChat== (the client), we will define trois other classes: the class ==TCMessage== which represents exchanged messages (as a future exercise you could extend TinyChat to use more structured elements such as JSON or STON (the Pharo object format), the class ==TCMessageQueue== which storesmessages and ==TCConsole== the graphical interface.!! Loading TeapotWe can load Teapot using the Configuration Browser that you can find in the Tools menu item of the main menu.Select Teapot and use "Install Stable". Another solution is to use the following script:[[[Gofer it    smalltalkhubUser: 'zeroflag' project: 'Teapot';    configuration;    loadStable.]]]Now we are ready to start.!! Message RepresentationA message is a really simple object with a text and sender identifier. !!! Class TCMessageWe define the class ==TCMessage== in the package ==TinyChat==.[[[Object subclass: #TCMessage	instanceVariableNames: 'sender text separator'	classVariableNames: ''	category: 'TinyChat']]]The instances variables are the following ones: - ==sender==: the identifier of the sender,- ==text==: the message text, and - ==separator==: a character for the separating the sender and the text.!!! Accessor creationWe create the following accessors:[[[TCMessage >> sender	^ senderTCMessage >> sender: anObject	sender := anObjectTCMessage >> text	^ textTCMessage >> text: anObject	text := anObject]]]!!! Instance InitialisationEach time an instance is created, its ==initialize== method is invoked. We redefine this method to set the separator value to the string ==>==.[[[TCMessage >> initialize	super initialize.	separator := '>'.]]]Now we create a class method named ==from:text:== to instantiate a message (a class method is a method that will be executed on a class and not on an instance of this class):[[[TCMessage class >> from: aSender text: aText	^ self new sender: aSender; text: aText; yourself]]]The message ==yourself== returns the message receiver: this way we ensure that the returned object is the new instance and not the returned value of the ==text:== message. This definition is equivalent to the following one:[[[TCMessage class >> from: aSender text: aText	| instance |	instance := self new.	instance sender: aSender; text: aText.	^ instance]]]!!! Converting a message object into a stringWe add the method ==printOn:== to transform an object message into a character string.The model we use is sender-separator-text-crlf. Example: 'john>hello !!!'.The method ==printOn:== est automatically invoked by the method ==printString==. This method is invoked by tools suchas the debugger or object inspector. [[[TCMessage >> printOn: aStream	aStream 		<< self sender; << separator; 		<< self text; << String crlf]]]!!! Building a message from a string We also define two methods to create a message object from a plain string of the form: =='olivier>tinychat est cool'==.First we create the  method ==fromString:== filling up the instance variables of an instance. It will be invoked the following way: ==TCMessage new fromString: 'olivier>tinychat est cool'==, then the class method ==fromString:== which invoked the previously instance.[[[TCMessage >> fromString: aString	"Compose a message from a string of this form 'sender>message'."	| items |	items := aString subStrings: separator.	self sender: items first.	self text: items second.]]]You can test the instance method with the following expression ==TCMessage new fromString: 'olivier>tinychat est cool'==.[[[TCMessage class >> fromString: aString	^ self new 		fromString: aString;		yourself]]]When you execute the following expression ==TCMessage fromString: 'olivier>tinychat est cool'== you should get a message.We are now ready to work on the server.!!The Chat ServerFor the server, we are going to define a class to manage a message queue. This is not really mandatory but it allowsto separate responsibilities. !!!Storing messagesCreate the class ==TCMessageQueue== in the package ''TinyChat-Server''. [[[Object subclass: #TCMessageQueue	instanceVariableNames: 'messages'	classVariableNames: ''	category: 'TinyChat-server']]]The ==messages== instance variable is an ordered collection whose contents are instances ==TCMessage==.An ==OrderedCollection== is a collection which dynamically grows when elements are added to it.We add an instance initialize method so that each new instance gets a proper messages collection.[[[TCMessageQueue >> initialize	super initialize.	messages := OrderedCollection new.]]]!!!! Basic operations on message list We should be able to add, clear the list and count the number of messages. We define then three methods: ==add:==, ==reset==, and ==size==.[[[TCMessageQueue >> add: aMessage	messages add: aMessage TCMessageQueue >> reset	messages removeAllTCMessageQueue >> size	^ messages size]]]!!!! List of message from a position When a client asks the server about the list of the last exchanged messages, it mentions the index of the lastmessage it knows. Then the server answers the list of received messages since this index.[[[TCMessageQueue >> listFrom: aIndex	^ (aIndex > 0 and: [ aIndex <= messages size]) 		ifTrue: [ messages copyFrom: aIndex to: messages size ]		ifFalse: [ #() ]]]]!!!! Message formattingThe server should be able to transfert a list of messages to its client given an index.We add then  the possibility to format a list of messages (given on index).We define the method ==formattedMessagesFrom:== using the formating of a single messages as follows:[[[TCMessageQueue >> formattedMessagesFrom: aMessageNumber		^ String streamContents: [ :formattedMessagesStream |  		(self listFrom: aMessageNumber) 			do: [ :m | formattedMessagesStream << m printString ] 		]]]]Note how the ==streamContents:== lets us manipulate a stream of characters. !!! The Chat ServerThe core of the server is based on the REST Teapot framework. It supports the send and receipt of messages.In addition this server keeps a list of messages that it communicates to clients. !!! TCServer class creationWe create the class ==TCServer== in the ''TinyChat-Server'' package. [[[Object subclass: #TCServer	instanceVariableNames: 'teapotServer messagesQueue'	classVariableNames: ''	category: 'TinyChat-Server']]]The instance variable ==messagesQueue== represents the list of received and sent messages.We initialize as such. [[[TCServer >> initialize	super initialize.	messagesQueue := TCMessageQueue new.]]]The instance variable ==teapotServer== refers to the instance of the Teapot server that we can create using the method ==initializePort:==[[[TCServer >> initializePort: anInteger	teapotServer := Teapot configure: { 		#defaultOutput -> #text.		#port -> anInteger.		#debugMode -> true	}.	teapotServer start.]]]The HTTP routes are define in the method ==registerRoutes==. Three operations are defined: - GET ==messages/count==: returns to the client the number of messages received by the server, - GET ==messages/<id:IsInteger>==: the server returns messages from an index, and- POST ==/message/add==: the client sends a new message to the server.[[[TCServer >> registerRoutes	teapotServer		GET: '/messages/count' -> (Send message: #messageCount to: self);		GET: '/messages/<id:IsInteger>' -> (Send message: #messagesFrom: to: self);		POST: '/messages/add' -> (Send message: #addMessage: to: self)]]]We express here that the path ==message/count== will execute the message ==messageCount== on the server itself.The pattern ==<id:IsInteger>== indicates that the argument should be expressed as number and that it will be convertedinto an integer. Error handling is managed in the method ==registerErrorHandlers==. Here we see how we can get an instance of the class ==TeaResponse==.[[[TCServer >> registerErrorHandlers	teapotServer		exception: KeyNotFound -> (TeaResponse notFound body: 'No such message')]]]Starting the server is done in the class method ==TCServer class>>startOn:== that get the TCP port as argument. [[[TCServer class >> startOn: aPortNumber	^self new		initializePort: aPortNumber;		registerRoutes;		registerErrorHandlers;		yourself]]]We should also offer the possibility to stop the server. The method ==stop== stop the teapot server and empty the message list. [[[TCServer >> stop	teapotServer stop.	messagesQueue reset.]]]Since there is a chance that you execute multiple times the expression ==TCServer startOn:==, we define the class method  ==stopAll== which stops all the servers by iterating over all the instance of the class ==TCServer==. The method ==TCServer class>>stopAll== stop each server. [[[TCServer class >> stopAll	self allInstancesDo: #stop]]]!!! Traitements réalisés par le serveurLa méthode ==addMessage== extrait de la requête du client le message posté. Elle ajoute à la liste des messages une nouvelle instance de ==TCMessage==.[[[TCServer >> addMessage: aRequest	messagesQueue add: (TCMessage from: (aRequest at: #sender) text: (aRequest at: #text)).]]]La méthode ==messageCount== retourne le nombre de messages reçus.[[[TCServer >> messageCount	^ messagesQueue size]]]La méthode ==messageFrom:== retourne la liste des messages reçus par le serveur depuis l'index indiqué par le client. Les messages sont retournés au client sous la forme d'une chaine de caractères. Ce point sera définitivement à améliorer. [[[TCServer >> messagesFrom: request	^ messagesQueue formattedMessagesFrom: (request at: #id)  ]]]Nous en avons fini avec le server. Nous pouvons maintenant le tester un peu. Commençons par le lancer : [[[	TCServer startOn: 8181]]]Maintenant nous pouvons soit vérifier avec un navigateur web (figure *running*), soit à l'aide du client/serveur Zinc disponible par défaut dans Pharo.[[[ZnClient new url: 'http://localhost:8181/messages/count' ; get]]]Les amateurs du shell peuvent également utiliser la commande curl [[[	curl http://localhost:8181/messages/count]]]+Testons le serveur.>file://figures/running.png|width=80|label=running+Nous pouvons aussi ajouter un message de la manière suivante : [[[ZnClient new 	url: 'http://localhost:8181/messages/add';	formAt: 'sender' put: 'olivier';	formAt: 'text' put: 'Super cool ce tinychat' ; post]]]!! Le clientMaintenant, nous pouvons nous concentrer sur la partie client de TinyChat. Le client se compose de deux classes:- ==TinyChat== est la classe contenant la logique métier (connexion, envoi et réception des messages),- ==TCConsole== est une classe définissant l'interface graphique.La logique du client est la suivante:- Au lancement du client, celui-ci demande au serveur l'index du dernier message reçu,- Toutes les deux secondes, le client se connecte au serveur pour lire les messages échangés depuis sa dernière connexion. Pour cela, il transmet au serveur l'index du dernier message dont il a eu connaissance.De plus, lorsque le client transmet un message au serveur, il en profite pour également lire les messages échangés depuis sa dernière connexion.!!!! La classe TinyChatNous créons la classe ==TinyChat== dans le package ==TinyChat-client==. [[[Object subclass: #TinyChat	instanceVariableNames: 'url login exit messages console lastMessageIndex'	classVariableNames: ''	category: 'TinyChat-client']]]Cette classe définit les variables suivantes:- url contient l'url HTTP permettant au client de se connecter au serveur,- login est une chaîne de caractères identifiant le client,- messages est une variable d'instance contenant les messages lus par le client,- lastMessageIndex est le numéro du dernier message lu par le client,- exit est une valeur booléenne. Tant que cette valeur est vraie, le client se connecte à intervalle régulier au serveur pour lire les messages échangés depuis sa dernière connexion,- console pointe sur l'instance de la console graphique permettant à l'utilisateur de saisir et de consulter les messages.Nous initialisons les variables qui le nécessitent dans la méthode ==initialize== suivante.[[[TinyChat >> initialize	super initialize.	exit := false.	lastMessageIndex := 0.	messages := OrderedCollection new.]]]!!!! Définir les commandes HTTPNous définissons les méthodes pour communiquer avec le serveur. Elles respectent le protocole HTTP.Deux méthodes permettent de formater la requête. L'une n'a pas d'argument et permet de construire les requêtes ==/messages/add== et ==/messages/count==. L'autre a un argument qui est utilisé pour la lecture des messages à partir d'une position.[[[TinyChat >> command: aPath	^'{1}{2}' format: { url . aPath }TinyChat >> command: aPath argument: anArgument	^'{1}{2}/{3}' format: { url . aPath . anArgument asString }]]]Il suffit ensuite de définir les trois commandes HTTP du client:[[[TinyChat >> cmdLastMessageID	^ self command: '/messages/count'TinyChat >> cmdNewMessage	^self command: '/messages/add'TinyChat >> cmdMessagesFromLastIndexToEnd	"Returns the server messages from my current last index to the last one on the server."	^ self command: '/messages' argument: lastMessageIndex]]]!!!!Gérer les opérations du clientNous avons besoin d'émettre ces commandes et de pouvoir récupérer des informations à partir du serveur.Pour cela, nous définissons deux méthodes. La méthode ==readLastMessageID== retourne l'index du dernier message reçu par le serveur.[[[TinyChat >> readLastMessageID	| id |	id := (ZnClient new url: self cmdLastMessageID; get) asInteger.	id = 0 ifTrue: [ id := 1 ].	^ id]]]La méthode ==readMissingMessages== ajoute les derniers messages reçus par le serveur à la liste des messages connus par le client. Cette méthode retourne le nombre de messages récupérés.[[[TinyChat >> readMissingMessages	"Gets the new messages that have been posted since the last request."	| response receivedMessages |	response := (ZnClient new url: self cmdMessagesFromLastIndexToEnd; get).	^ response 		ifNil: [ 0 ]		ifNotNil: [  			receivedMessages := response subStrings: (String crlf).			receivedMessages do: [ :msg | messages add: (TCMessage fromString: msg) ].			receivedMessages size.		].]]]Nous sommes prêt à définir le comportement de rafraichissement du client avec la  méthode ==refreshMessages==.Elle utilise un processus léger pour lire à intervalle régulier les messages reçus par le serveur. Le délai est fixé à deux secondes.Le message ==fork== envoyé à un bloc (une fermeture lexical en Pharo) exécute ce bloc dans un processus léger. La logique estde boucler tant que le client ne spécifie pas que veut s'arrêter via la variable ==exit==. L'expression ==(Delay forSeconds: 2) wait== suspend l'exécution du processus léger dans lequel elle se trouve pendant un certain nombre de secondes. [[[TinyChat >> refreshMessages	[  		[ exit ] whileFalse: [  			(Delay forSeconds: 2) wait.			lastMessageIndex := lastMessageIndex + (self readMissingMessages).			console print: messages.		]	] fork]]]La méthode ==sendNewMessage:== poste le message de l'utilisateur au serveur.[[[TinyChat >> sendNewMessage: aMessage	^ ZnClient new		url: self cmdNewMessage;		formAt: 'sender' put:  (aMessage sender);		formAt: 'text' put: (aMessage text);		post]]]Cette méthode est utilisée par la méthode ==send:== qui reçoit en paramètre le texte saisi par l'utilisateur. La chaine de caractères est alors convertie en une instance de ==TCMessage==. Le message est envoyé. Le client met à jour l'index du dernier message connu et déclenche l'affichage du message dans l'interface graphique.[[[TinyChat >> send: aString	"When we send a message, we push it to the server and in addition we update the local list of posted messages."		| msg |	msg := TCMessage from: login text: aString.	self sendNewMessage: msg.	lastMessageIndex := lastMessageIndex + (self readMissingMessages).	console print: messages.]]]La déconnexion du client est gérée par la méthode ==disconnect== qui envoie un message au serveur pour signaler le départ de l'utilisateur et met fin à la boucle de récupération périodique des messages.[[[TinyChat >> disconnect	self sendNewMessage: (TCMessage from: login text: 'I exited from the chat room.').	exit := true]]]!!!! Fixer les paramètres du clientPour initialiser les paramètres de connexion, on définit une méthode de class ==TinyChat class>>connect:port:login:==. Cette méthode permet de se connecter de la manière suivante : ==TinyChat connect: 'localhost' port: 8080 login: 'username'==[[[TinyChat class >> connect: aHost port: aPort login: aLogin	^ self new		host: aHost port: aPort login: aLogin;		start]]]Le code appelle la méthode ==host:port:login:==. Cette méthode met à jour la variable d'instance ==url== en construisant l'URL et en affectant le nom de l'utilisateur à la variable d'instance ==login==.[[[TinyChat >> host: aHost port: aPort login: aLogin	url := 'http://' , aHost , ':' , aPort asString.	login := aLogin]]]La méthode ==start== envoie un message au serveur pour présenter l'utilisateur, récupèrer l'index du dernier message reçu par le serveur et mettre à jour la liste des messages connus par le client. C'est également cette méthode qui initialise l'interface graphique de l'utilisateur. Une évolution pourrait être de décoreller le modèle de son interface graphique en utilisant une conception basée sur des évenements.[[[TinyChat >> start	console := TCConsole attach: self.	self sendNewMessage: (TCMessage from: login text: 'I joined the chat room').	lastMessageIndex := self readLastMessageID.	self refreshMessages.]]]!!!! Création de l'interface graphiqueL'interface graphique est composée d'une fenêtre contenant une liste et un champ de saisie comme montré dans la figure *tinychatclient*. [[[ComposableModel subclass: #TCConsole	instanceVariableNames: 'chat list input'	classVariableNames: ''	category: 'TinyChat-client']]]La variable d'instance ==chat== est une référence à une instance de la classe ==TinyChat== et nécessite uniquement un accesseur en écriture. Les variables d'instance ==list== et ==input== dispose chacune d'un accesseur en lecture. Ceci est imposé par Spec le constructeur d'interface.[[[TCConsole >> input	^ inputTCConsole >> list	^ listTCConsole >> chat: anObject	chat := anObject]]]L'interface graphique a un titre pour la fenêtre. Pour le définir, il faut écrire une méthode ==title==.[[[TCConsole >> title	^ 'TinyChat']]]La méthode de classe ==TCConsole class>>attach:== reçoit en argument l'instance du client de chat avec lequel l'interface graphique va être utilisée. Cette méthode déclenche l'ouverture de la fenêtre et met en place l'événement gérant la fermeture de celle ci et donc, provoquant la déconnexion du client. [[[TCConsole class >> attach: aTinyChat	| window |	window := self new chat: aTinyChat.	window openWithSpec whenClosedDo: [ aTinyChat disconnect ].	^ window]]]La méthode ==TCConsole class>>defaultSpec== définit la mise en page des composants contenus dans la fenêtre. Ici nous avons une colonne avec une listeet un champ de saisie placé juste en dessous.[[[TCConsole class >> defaultSpec	<spec: #default>	^ SpecLayout composed		newColumn: [ :c | 			c add: #list; add: #input height: 30 ]; yourself]]]La méthode ==initializeWidgets== spécifie la nature et le comportement des composants graphiques. Ainsi le ==acceptBlock:== permet de définir l'action à exécuter lorsque le texteest entré dans le champ de saisie. Ici nous l'envoyons à client et nous le vidons.[[[TCConsole >> initializeWidgets	list := ListModel new.	input := TextInputFieldModel new 		ghostText: 'Type your message here...';		enabled: true;		acceptBlock: [ :string |  			chat send: string. 			input text: '' ].	self focusOrder add: input.]]]La méthode ==print== affiche les messages reçus par le client en les affectant au contenu de la liste.[[[TCConsole >> print: aCollectionOfMessages	list items: (aCollectionOfMessages collect: [  :m |  m printString ])]]]Notez que cette méthode est invoquée par la méthode ==refreshMessages== et que changer tous les éléments de la listeà chaque ajout d'un nouveau messages est peu élégant mais l'exemple se veut volontairement simple. +Acces direct au server.>file://figures/messages.png|width=60|label=messages+Voilà vous pouvez maintenant chatter avec votre serveur. !! ConclusionNous avons montré que la création d'un serveur REST est extrêmement simple avec Teapot. La définition de TinyChat donne un cadre ludique à l'exploration de la programmation en Pharo et nous esperons que vous avez apprécié cette ballade. TinyChat est une petite application que nous avons développé de manière très simple afin  de vous permettre de l'étendre et d'expérimenter. Voici une liste d'améliorations : gestion parcimonieuse des ajouts d'éléments dans la liste graphique, gestion d'accès concurrents dans la collection sur le serveur (en effet, si le serveur pouvait recevoir des requêtes concurrentes la structure de donnée utilisée n'est pas adéquate), gestion des erreurs de connexion,rendre les clients robustes à la fermeture du serveur, obtenir la liste des personnes connectées, pouvoir définir le délai de récupération des messages, utiliser JSON pour le transport des messages, afficher le nom de la personne connectée dans la fenêtre. Le projet est disponible à l'adresse *http://www.smalltalkhub.com/#!/~olivierauverlot/TinyChat*. A vous de jouer!