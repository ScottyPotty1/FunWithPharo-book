!! First Test[[[	Object subclass: #Wallet		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Wallet'	]]][[[TestCase subclass: #WalletTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Wallet']]][[[WalletTest >> testWalletAtCreationIsZero	| w |	w := Wallet new.	self assert: w money = 0]]][[[Wallet >> money	^ 0]]]!! Adding coins[[[WalletTest >> testCoins	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	w add: 3 coinsOfValue: 0.20.	self assert: w coins = 5]]]	[[[	"protocol: adding/removing"Wallet >> add: anInteger coinsOfValue: aNumber	"Add to the receiver, anInteger times a coin of value aNumber"		bagCoins add: aNumber withOccurrences: anInteger ]]][[[	"protocol: initialize"Wallet >> initialize	bagCoins := Bag new]]][[[Wallet >> coins: aNumber	^ bagCoins occurrencesOf: aNumber]]]should be renamed coinsOfValue: !! Revisiting Names[[[Wallet >> coinsOfValue: aNumber	"Return the number of coins for aNumber. For example if the receiver has 5 coins of 0.2. 	coinsOfValue: 0.2 returns 5"		^ bagCoins occurrencesOf: aNumber]]][[[WalletTest >> testCoinsAddition	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	self assert: (w coinsOfValue: 0.5) = 2]]][[[WalletTest >> testCoinsAdditionISWorking	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	w add: 6 coinsOfValue: 0.50.	self assert: (w coinsOfValue: 0.5) = 8]]]!! Money[[[WalletTest >> testMoney	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	w add: 3 coinsOfValue: 0.20.	w add: 1 coinsOfValue: 0.02.	self assert: w money = 1.62]]][[[Wallet >> money	| money |	money := 0.	bagCoins doWithOccurrences:			[ :elem :occurrence | 				money := money + ( elem * occurrence) ].	^ money]]][[[WalletTest >> testMoney2	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	w add: 3 coinsOfValue: 0.20.	w add: 1 coinsOfValue: 0.02.	w add: 5 coinsOfValue: 0.05.	self assert: w money = 1.87]]][[[Wallet >> money	"Return the value of the receiver by summing its constituents"	| money |	money := 0.	bagCoins doWithOccurrences:			[ :elem : occurrence | 				money := money + ( elem * occurrence ) ].	^ money]]]!! Pay[[[WalletTest >> testCanPay	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	w add: 3 coinsOfValue: 0.20.	w add: 1 coinsOfValue: 0.02.	w add: 5 coinsOfValue: 0.05.	self assert: (w canPay: 2) not.	self assert: (w canPay: 0.50).]]][[[Wallet >> canPay: amounOfMoney	"returns true when we can pay the amount of money"	^ self money >= amounOfMoney]]][[[WalletTest >> testBiggestCoins	| w |	w := Wallet new.	w add: 10 coinsOfValue: 0.50.	w add: 10 coinsOfValue: 0.20.	w add: 10 coinsOfValue: 0.10.	self assert: w biggest equals: 0.50.]]]	[[[Wallet >> biggest	"Returns the biggest coin with a value below anAmount. For example, {(3 -> 0.5) . (3 -> 0.2) . (5-> 0.1)} biggest -> 0.5"	^ bagCoins sortedElements last key]]][[[Wallet >> biggestBelow: anAmount	"Returns the biggest coin with a value below anAmount. For example, {(3 -> 0.5) . (3 -> 0.2) . (5-> 0.1)} biggestBelow: 0.40 -> 0.2"		bagCoins doWithOccurrences: [ :elem :occurrences |			anAmount >= elem ifTrue: [ ^ elem ] ].]]]	