!! First Test[[[	Object subclass: #Wallet		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Wallet'	]]][[[TestCase subclass: #WalletTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Wallet']]][[[WalletTest >> testWalletAtCreationIsZero	| w |	w := Wallet new.	self assert: w money = 0]]][[[Wallet >> money	^ 0]]]!! Adding coins[[[WalletTest >> testCoins	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	w add: 3 coinsOfValue: 0.20.	self assert: w coinNumber= 5]]]	[[[	"protocol: adding/removing"Wallet >> add: anInteger coinsOfValue: aNumber	"Add to the receiver, anInteger times a coin of value aNumber"		bagCoins add: aNumber withOccurrences: anInteger ]]][[[	"protocol: initialize"Wallet >> initialize	bagCoins := Bag new]]][[[Wallet >> coins: aNumber	^ bagCoins occurrencesOf: aNumber]]]should be renamed coinsOfValue: !! Revisiting Names[[[Wallet >> coinsOfValue: aNumber	"Return the number of coins for aNumber. For example if the receiver has 5 coins of 0.2. 	coinsOfValue: 0.2 returns 5"		^ bagCoins occurrencesOf: aNumber]]][[[WalletTest >> testCoinsAddition	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	self assert: (w coinsOfValue: 0.5) = 2]]][[[WalletTest >> testCoinsAdditionISWorking	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	w add: 6 coinsOfValue: 0.50.	self assert: (w coinsOfValue: 0.5) = 8]]]!! Money[[[WalletTest >> testMoney	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	w add: 3 coinsOfValue: 0.20.	w add: 1 coinsOfValue: 0.02.	self assert: w money = 1.62]]][[[Wallet >> money	| money |	money := 0.	bagCoins doWithOccurrences:			[ :elem :occurrence | 				money := money + ( elem * occurrence) ].	^ money]]][[[WalletTest >> testMoney2	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	w add: 3 coinsOfValue: 0.20.	w add: 1 coinsOfValue: 0.02.	w add: 5 coinsOfValue: 0.05.	self assert: w money = 1.87]]][[[Wallet >> money	"Return the value of the receiver by summing its constituents"	| money |	money := 0.	bagCoins doWithOccurrences:			[ :elem : occurrence | 				money := money + ( elem * occurrence ) ].	^ money]]]!! Pay[[[WalletTest >> testCanPay	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	w add: 3 coinsOfValue: 0.20.	w add: 1 coinsOfValue: 0.02.	w add: 5 coinsOfValue: 0.05.	self assert: (w canPay: 2) not.	self assert: (w canPay: 0.50).]]][[[Wallet >> canPay: amounOfMoney	"returns true when we can pay the amount of money"	^ self money >= amounOfMoney]]][[[WalletTest >> testBiggestCoins	| w |	w := Wallet new.	w add: 10 coinsOfValue: 0.50.	w add: 10 coinsOfValue: 0.20.	w add: 10 coinsOfValue: 0.10.	self assert: w biggest equals: 0.50.]]]	[[[Wallet >> biggest	"Returns the biggest coin with a value below anAmount. For example, {(3 -> 0.5) . (3 -> 0.2) . (5-> 0.1)} biggest -> 0.5"	^ bagCoins sortedElements last key]]][[[WalletTest >> testBiggestCoinsBelow	| w |	w := Wallet new.	w add: 10 coinsOfValue: 0.50.	w add: 10 coinsOfValue: 0.20.	w add: 10 coinsOfValue: 0.10.	self assert: (w biggestBelow: 1) equals: 0.50.	self assert: (w biggestBelow: 0.5) equals: 0.20.	self assert: (w biggestBelow: 0.48) equals: 0.20.	self assert: (w biggestBelow: 0.20) equals: 0.10.	self assert: (w biggestBelow: 0.10) equals: 0.]]][[[Wallet >> biggestBelow: anAmount	"Returns the biggest coin with a value below anAmount. For example, {(3 -> 0.5) . (3 -> 0.2) . (5-> 0.1)} biggestBelow: 0.40 -> 0.2"		bagCoins doWithOccurrences: [ :elem :occurrences |			anAmount > elem ifTrue: [ ^ elem ] ].	^ 0]]]	!! Improving the API[[[Wallet >> printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' (', self money asString, ')']]][[[WalletTest >> testAddOneCoin	| w |	w := Wallet new.	w addCoin: 0.50.	self assert: (w coinsOfValue: 0.5) = 1.	self assert: w money equals: 0.5]]][[[Wallet >> addCoin: aNumber	"Add to the receiver a coin of value aNumber"		bagCoins add: aNumber withOccurrences: 1 ]]][[[WalletTest >> testRemove	| w |	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	w add: 3 coinsOfValue: 0.20.	w add: 1 coinsOfValue: 0.02.	w add: 5 coinsOfValue: 0.05.	w removeCoin: 0.5.	self assert: w money = 1.37]]][[[Wallet >> removeCoin: aNumber	"Remove from the receiver a coin of value aNumber"		bagCoins remove: aNumber ifAbsent: [] ]]][[[Wallet >> remove: anInteger coinsOfValue: aNumber	"Remove from the receiver, anInteger times a coin of value aNumber"	bagCoins add: aNumber withOccurrences: anInteger ]]][[[Wallet >> biggestAndRemove	| b |	b := self biggest.	self removeCoin: b.	^ b	]]][[[WalletTest >> testEmpty	| w |	w := Wallet empty.	self assert: w money equals: 0]]][[[Wallet >> empty	^ Wallet new]]]!! Coins for Paying: First Version[[[WalletTest >> testCoinsForPaying	| w paid |	w := Wallet new.	w add: 10 coinsOfValue: 0.50.	w add: 10 coinsOfValue: 0.20.	w add: 10 coinsOfValue: 0.10.	paid := (w coinsFor: 2.5).	self assert: paid money equals: 2.5.	self assert: (paid coinsOfValue: 0.5) equals: 5 ]]][[[Wallet >> coinsFor: aValue	"Returns the largest coins to pay a certain amount and an empty wallet if this is not possible"	| res |	res := self class empty.	^ (self canPay: aValue)		ifFalse: [ res ]		ifTrue: [ self coinsFor: aValue into2: res ] ]]][[[Wallet >> coinsFor: aValue into: accuWallet		| big |	[ accuWallet money < self money ]			whileTrue: [ big := self biggestAndRemove.						accuWallet addCoin: big ].	^ accuWallet]]!! Better Heuristics[[[WalletTest >> testCoinsForPayingWithOtherCoins	| w paid |	w := Wallet new.	w add: 1 coinsOfValue: 0.50.	w add: 10 coinsOfValue: 0.20.	w add: 10 coinsOfValue: 0.10.	paid := (w coinsFor: 2.4).	self assert: paid money equals: 2.4.	self assert: (paid coinsOfValue: 0.5) equals: 1.	self assert: (paid coinsOfValue: 0.2) equals: 9.]]][[[WalletTest >> testCoinsForPayingWithOtherThanTop	| w paid | 	w := Wallet new.	w add: 1 coinsOfValue: 0.50.	w add: 10 coinsOfValue: 0.20.	w add: 10 coinsOfValue: 0.10.	paid := (w coinsFor: 0.6).	self assert: paid money equals: 0.6.	self assert: (paid coinsOfValue: 0.5) equals: 1.	self assert: (paid coinsOfValue: 0.1) equals: 1.]]][[[WalletTest >> testCoinsForPayingWithOtherThanTopMoreDifficult	| w paid | 	w := Wallet new.	w add: 2 coinsOfValue: 0.50.	w add: 10 coinsOfValue: 0.20.	w add: 10 coinsOfValue: 0.10.	paid := (w coinsFor: 0.6).	self assert: paid money equals: 0.6.	self assert: (paid coinsOfValue: 0.5) equals: 1.	self assert: (paid coinsOfValue: 0.1) equals: 1.]]][[[WalletTest >> testCoinsForPayingWithOtherThanTopMoreDifficult2	| w paid | 	w := Wallet new.	w add: 1 coinsOfValue: 1.	w add: 2 coinsOfValue: 0.50.	w add: 10 coinsOfValue: 0.20.	w add: 10 coinsOfValue: 0.10.	paid := (w coinsFor: 0.6).	self assert: paid money equals: 0.6.	self assert: (paid coinsOfValue: 0.5) equals: 1.	self assert: (paid coinsOfValue: 0.1) equals: 1.]]][[[Wallet >> coinsFor: aValue into2: accuWallet	| accu |	[ accu := accuWallet money. 	accu < aValue ] 		whileTrue: [ 				| big |				big := self biggest.				[ big > ((aValue - accu) roundUpTo:  0.1)  ] whileTrue: [						 big := self biggestBelow: big ].				self removeCoin: big.				accuWallet addCoin: big ].	^ accuWallet ]]]